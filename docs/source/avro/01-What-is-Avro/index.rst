What is Avro
==============================================================================


Avro Overview
------------------------------------------------------------------------------
Avro 数据格式是一个里面包含了 Schema 的信息, 以及数据本身的二进制格式. 数据的 Schema 是用 JSON 定义的. 而数据本身则是用二进制格式保存的, 不包含 key, 只有 value, 非常紧凑, 并且适合压缩. 一个文件必然要包含一个 Schema, 所以为了最大化利用空间, 一般是一个文件 (或是一个 binary 对象) 里面保存很多条数据. 你写数据的时候需要带上 Schema, 而读的时候不需要 (已经包含在文件里了)

Avro 数据格式是 Row based 的, 也就是说数据是一条一条的储存的. 跟 JSON 相比, 因为无需储存 Key, 所以它的体积要比 JSON 小. 不过 JSON 无需特殊工具, 人类即可读写, 而 Avro 需要特定工具.


Avro vs Protocol Buffers
------------------------------------------------------------------------------
这两个格式都是著名的 Schema enforce 格式. 常常被放在一起比较. 这里我们对它们进行一个区分.

从工作原理来看, Avro 的 Schema 要保存在一个 JSON 文件中. 而 Protocol Buffer 的 Schema 是用代码来定义的. 对于不同 Schema 的数据 Avro 读写的代码只需要写一份, 因为只要指定不同的 Schema 文件即可. 而 Protocol Buffer 则需要为不同的 Schema 写不同的代码. 即使有工具可以从 Schema 自动生成对应语言的代码.

从使r
用场景来看, Avro 主要是用于 Schema 快速变化的场景, 杀手功能是能保持 Schema 兼容性, 主要用于对于数据验证要求高的行业, 例如政府, 金融. 而 Protocol Buffer 主打一个高性能, 低延迟. 主要用于对于性能要求高的场景, 例如 Google 的内部 RPC 通信, 游戏服务器.


Avro Use Case
------------------------------------------------------------------------------
官方给出的使用场景是: 适合在不同系统之间大规模交换数据.

这里结合我的工作经验, 列出一些适合 Avro 的使用场景:

- Stream data processing: Avro 很适合将很多条数据编码成为一个 Payload, 通过流数据系统例如 Kafka, Kinesis 发送出去. 因为它自带 Schema, 比较容易节约空间, 而且无需再代码中维护 Schema, 直接通过数据传输.